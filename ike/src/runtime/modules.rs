use crate::prepare::transpile;
use boa_engine::{
    module::ModuleLoader, Context, JsNativeError, JsResult, JsString, JsValue, Module, Source,
};
use oxc_resolver::{EnforceExtension, ResolveOptions, Resolver};
use std::{collections::HashMap, vec};

#[derive(Debug, Default)]
pub struct IkeModuleLoader;

// ! js folder is generated by the unbuild packages. Until we have a way of hanlding ts files.
lazy_static::lazy_static! {
    static ref BUILTIN_MODULES: HashMap<&'static str, String> = {
        let mut m = HashMap::new();
        m.insert("util", include_str!("js\\util.mjs").to_string());
        m.insert("buffer", include_str!("js\\buffer.mjs").to_string());
        m.insert("test", include_str!("js\\test.mjs").to_string());
        m.insert("assert", include_str!("js\\assert.mjs").to_string());
        m.insert("inspect", include_str!("js\\inspect.mjs").to_string());
        m.insert("_internal_", include_str!("js\\_internal_.mjs").to_string());
        m.insert("path", include_str!("js\\path.mjs").to_string());
        m
    };
}

impl ModuleLoader for IkeModuleLoader {
    fn load_imported_module(
        &self,
        _referrer: boa_engine::module::Referrer,
        specifier: JsString,
        finish_load: Box<dyn FnOnce(JsResult<Module>, &mut Context)>,
        context: &mut Context,
    ) {
        let spec = specifier.to_std_string_escaped();

        if is_builtin_module(&spec) {
            let stripped_spec = strip_spec(&spec);
            let source = Source::from_bytes(BUILTIN_MODULES.get(stripped_spec).unwrap().as_bytes());
            let module = Module::parse(source, None, context);

            finish_load(module, context);
        } else {
            let ref_path = match _referrer.path().unwrap().parent() {
                Some(parent) => parent,
                None => {
                    finish_load(
                        Err(JsNativeError::typ()
                            .with_message("Failed to get parent directory")
                            .into()),
                        context,
                    );
                    return;
                }
            };

            let options = ResolveOptions {
                enforce_extension: EnforceExtension::Disabled,
                condition_names: vec!["node".into(), "import".into()],
                extensions: vec![
                    ".js".into(),
                    ".mjs".into(),
                    ".ts".into(),
                    ".mts".into(),
                    ".cjs".into(),
                    ".cts".into(),
                ],
                ..ResolveOptions::default()
            };

            // TODO: implement our own resolver because of the difference in package.json and ike.toml
            match Resolver::new(options).resolve(ref_path, &spec) {
                Err(error) => println!("Error: {error}"),
                Ok(resolution) => {
                    let file = resolution.full_path();
                    let transpiled = match transpile(&file) {
                        Ok(transpiler) => transpiler,
                        Err(e) => {
                            finish_load(
                                Err(JsNativeError::typ().with_message(e.to_string()).into()),
                                context,
                            );
                            return;
                        }
                    };
                    // Wait until #3941 is released in the next version, so we can specify the path
                    let reader = Source::from_bytes(transpiled.as_bytes());
                    let module = Module::parse(reader, None, context);

                    finish_load(module, context);
                }
            }
        }
    }
}

pub fn strip_spec(specifier: &str) -> &str {
    if let Some(stripped) = specifier.strip_prefix("ike:") {
        stripped
    } else {
        specifier
    }
}

pub fn is_builtin_module(specifier: &str) -> bool {
    let name = strip_spec(specifier);

    BUILTIN_MODULES.contains_key(name)
}
